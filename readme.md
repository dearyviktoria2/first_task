# Сравнение создания массивов (списков) и организации стеков в Java, Python и C++ (Панченко Виктория Вадимовна, УИБО-10-24)

## 1. Python

### 1.1 Массив в Python
В Python в качестве массивов используются списки (list), которые являются динамической структурой данных и способны хранить элементы разных типов. 

```
list = [] - инициализация пустого списка
list = [1, "a", True] - элементом списка может быть любой тип данных
```
Добавить элемент в список можно на любое место.
Удалить из списка элемент можно как по индексу, так и по значению.
```
list.append("a") - добавит новый элемент "a" в конец списка
list.insert(x, "a") - добавит элемент "a" на место с индексом x
list.pop(x) - удалит из списка элемент на индексе x и вернет его в качестве результата
list.remove(x) - удалит из списка элемент СО ЗНАЧЕНИЕМ равным x (если таких элементов несколько - удалит первый попавшийся)
```
### 1.2 Стек в Python
Для реализации стека в Python часто используют класс Deque из модуля collections, который обеспечивает эффективное выполнение операций добавления и удаления элементов.

```
from collections import deque

stack = deque()

# Добавление элемента
stack.append('first')
stack.append('second')

# Извлечение последнего элемента
last_element = stack.pop() # second
```

## 2. Java

### 2.1 Массивы в Java
В Java массивы — это объекты, хранящие элементы одного типа фиксированного размера.
```
int[] numbers = new int[5]; // Массив из 5 целых чисел
String[] words = {"a", "b"}; // Инициализация значениями
```
### 2.2 Стек в Java
Для работы со стеком в Java используется класс Stack<T> из пакета java.util

```
import java.util.Stack
Stack<Integer> stack = new Stack<>(); - инициализация стека
Stack<Integer> stack = new Stack<>(); - инициализация стека
stack.push(10); - добавляем элементы в стек
int removedElement = stack.pop(); - удаляем и возвращаем верхний элемент

```

## 3. C++

### 3.1 Массивы в C++
Также как и в Java - массивы это объекты, которые хранят элементы одного типа фиксированного размера
```
int numbers[5]; - инициализация массива элементов типа integer
string students[] = {"Виктория", "Иван"}; - инициализация массива элементов типа string
```

В современном C++ как правило используют реализацию массива std::array.
```
#include <array>

int main() {
    std::array<int, 5> myArray = {5, 4, 3, 2, 1};
}

```
std::array отличается от обычного массива C++ следующим:

- Интерфейс: Имеет методы STL (.size(), .at(), .begin(), .end())
- Безопасность: .at() проверяет границы (кидает исключение)
- Копирование: Можно копировать оператором =
- Размер: Знает свой размер (.size())
- STL совместимость: Работает с алгоритмами STL

### 3.2 Стек в C++
В C++ для работы со стеком чаще всего используют контейнер std::stack 
```
#include <stack>

std::stack<int> MyStack; - инициализация стека
MyStack.push(10); - добавляет элемент в стек
int topElement = MyStack.top(); - Получаем верхний элемент
MyStack.pop(); - удаляем верхний элемент
```
## 4. Вывод
Каждый из представленных языков программирования имеет свой уникальный подход к работе с массивами и стеком.

### 4.1 Вывод по массивам
В Python массив реализован как динамическая структура данных (размер можно поменять, поддерживает любые типы данных), тогда как в Java и C++ это статическая структура данных с определённым типом данных и заранее заданным размером.

### 4.2 Вывод по стеку

Отличия в реализации стека в языках программирования Python, Java и C++ следующие

**Python**:  
- Использует список (`list`) или `collections.deque`  
- Динамическое расширение, проверка границ  
- **Плюсы**: простота, автоматическое управление памятью  

**Java**:  
- `Stack`
- Базируется на массивах, динамическое расширение  
- **Плюсы**: потокобезопасность 

**C++**:  
- `std::stack` 
- Жёсткий контроль памяти, шаблонная реализация  
- **Плюсы**: скорость, низкие накладные расходы, выбор контейнера  

**Ключевые различия**:  
- **Управление памятью**: Python/Java — автоматическое, C++ — ручное/RAII  
- **Безопасность**: Python/Java — проверка границ, C++ — опционально  
- **Производительность**: C++ → Java → Python (в порядке убывания)  
- **Гибкость**: C++ позволяет выбрать базовый контейнер







